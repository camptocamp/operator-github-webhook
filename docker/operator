#!/usr/bin/env python3

import datetime
import json
import logging
import os
import time
from typing import Dict, List, Tuple

import kubernetes  # type: ignore
import requests

LOG = logging.getLogger(__name__)


AUTH_HEADER = f"Bearer {os.environ['GITHUB_TOKEN']}"


def delete_webhook(url: str, repository: str, id_: int) -> None:
    result = requests.delete(
        f"https://api.github.com/repos/{repository}/hooks/{id_}",
        headers={
            "Accept": "application/vnd.github.v3+json",
            "Authorization": AUTH_HEADER,
        },
    )
    if not result.ok:
        LOG.warning("Unable to delete webhook %s on repository %s: %s", url, repository, result.text)
    else:
        LOG.info("Webhook %s on repository %s deleted", url, repository)
        LOG.debug(result.text)


class WebHook:
    def __init__(self, id_: int):
        self.id_ = id_
        # List of Kubernetes namespace, name
        self.objects: List[Tuple[str, str]] = []


class Main:
    def __init__(self):
        logging.basicConfig(level=os.environ.get("LOG_LEVEL", logging.INFO))
        # Needed when a webhook is defined tow times and we delete one
        # key: GitHub repository, Webhook URL
        self.webhooks: Dict[Tuple[str, str], WebHook] = {}
        # Needed on modification to know the old github token
        # k8s namespace, name: GitHub repository, Webhook URL
        self.k8s_webhook: Dict[Tuple[str, str], Tuple[str, str]] = {}

        try:
            kubernetes.config.load_kube_config()
        except:
            kubernetes.config.load_incluster_config()

        self.api = kubernetes.client.CoreV1Api()
        self.custom_api = kubernetes.client.CustomObjectsApi()
        self.watch = kubernetes.watch.Watch()
        self.watch_webhooks()

    def watch_webhooks(self) -> None:
        while True:
            try:
                LOG.info("GitHub WebHook creator started")
                LOG.debug("Start date: %s", datetime.datetime.now())
                for event in self.watch.stream(
                    self.custom_api.list_cluster_custom_object,
                    group="camptocamp.com",
                    version="v1",
                    plural="githubwebhooks",
                ):
                    try:
                        start = time.time()
                        metadata = event["object"]["metadata"]

                        LOG.info(
                            "Event %s, Service Name: %s, Namespace: %s",
                            event.get("type"),
                            metadata.get("name"),
                            metadata.get("namespace"),
                        )
                        LOG.debug("Receive event: %s", event)
                        LOG.debug("Event date: %s", datetime.datetime.now())

                        k8s_id: Tuple[str, str] = (metadata["name"], metadata["namespace"])
                        gh_id: Tuple[str, str] = (
                            event["object"]["spec"]["url"],
                            event["object"]["spec"]["repository"],
                        )

                        webhooks_response = requests.get(
                            f"https://api.github.com/repos/{event['object']['spec']['repository']}/hooks",
                            headers={
                                "Accept": "application/vnd.github.v3+json",
                                "Authorization": AUTH_HEADER,
                            },
                        )
                        if not webhooks_response.ok:
                            LOG.error(
                                "Unable to get webhooks for repository %s:\n%s",
                                event["object"]["spec"]["repository"],
                                webhooks_response.text,
                            )
                            continue
                        webhooks = webhooks_response.json()

                        if event["type"] == "DELETED":
                            delete_id = 0
                            if gh_id in self.webhooks:
                                self.webhooks[gh_id].objects.remove(k8s_id)
                                if len(self.webhooks[gh_id].objects) == 0:
                                    delete_id = self.webhooks[gh_id].id_
                                    del self.webhooks[gh_id]
                                else:
                                    continue
                            else:
                                for webhook in webhooks:
                                    try:
                                        if webhook["config"]["url"] == event["object"]["spec"][
                                            "url"
                                        ] and webhook["config"]["content_type"] == event["object"][
                                            "spec"
                                        ].get(
                                            "contentType", "json"
                                        ):
                                            delete_id = webhook["id"]
                                    except Exception as exception:  # pylint: disable=broad-except
                                        LOG.exception(
                                            "Error: %s\nWith webhook:\n%s\nOn event:\n%s",
                                            exception,
                                            json.dumps(webhook),
                                            json.dumps(event),
                                        )
                            if k8s_id in self.k8s_webhook:
                                del self.k8s_webhook[k8s_id]
                            delete_webhook(
                                event["object"]["spec"]["url"],
                                event["object"]["spec"]["repository"],
                                delete_id,
                            )
                            continue

                        if event["type"] == "MODIFIED":
                            LOG.debug("Delete old web hook")
                            if k8s_id in self.k8s_webhook:
                                webhook = self.webhooks[self.k8s_webhook[k8s_id]]
                                webhook.objects.remove(k8s_id)
                                if len(webhook.objects) == 0:
                                    delete_webhook(
                                        event["object"]["spec"]["url"],
                                        event["object"]["spec"]["repository"],
                                        self.webhooks[self.k8s_webhook[k8s_id]].id_,
                                    )
                                    del self.webhooks[self.k8s_webhook[k8s_id]]

                        found = False
                        for webhook in webhooks:
                            try:
                                if webhook["config"]["url"] == event["object"]["spec"]["url"] and webhook[
                                    "config"
                                ]["content_type"] == event["object"]["spec"].get("contentType", "json"):
                                    self.k8s_webhook[k8s_id] = gh_id
                                    if gh_id not in self.webhooks:
                                        self.webhooks[gh_id] = WebHook(webhook["id"])
                                    self.webhooks[gh_id].objects.append(k8s_id)
                                    found = True
                                    break
                            except Exception as exception:  # pylint: disable=broad-except
                                LOG.exception(
                                    "Error: %s\nWith webhook:\n%s\nOn event:\n%s",
                                    exception,
                                    json.dumps(webhook),
                                    json.dumps(event),
                                )
                        if not found:
                            result = requests.post(
                                f"https://api.github.com/repos/{event['object']['spec']['repository']}/hooks",
                                headers={
                                    "Accept": "application/vnd.github.v3+json",
                                    "Authorization": AUTH_HEADER,
                                },
                                json={
                                    "config": {
                                        "content_type": event["object"]["spec"].get("contentType", "json"),
                                        "url": event["object"]["spec"]["url"],
                                    }
                                },
                            )
                            if not result.ok:
                                LOG.error(
                                    "Unable to create webhook %s on repository %s:\n%s",
                                    event["object"]["spec"]["url"],
                                    event["object"]["spec"]["repository"],
                                    result.text,
                                )
                            else:
                                self.k8s_webhook[k8s_id] = gh_id
                                if gh_id not in self.webhooks:
                                    self.webhooks[gh_id] = WebHook(result.json()["id"])
                                self.webhooks[gh_id].objects.append(k8s_id)
                                LOG.info(
                                    "Webhook %s on repository %s created",
                                    event["object"]["spec"]["url"],
                                    event["object"]["spec"]["repository"],
                                )
                                LOG.debug(result.text)
                        LOG.debug("Elapse time on the event %s", time.time() - start)

                    except Exception as exception:  # pylint: disable=broad-except
                        LOG.exception(
                            "Error: %s\nOn event:\n%s",
                            exception,
                            json.dumps(event),
                        )
                LOG.error("The watch exited, continuing")
            except:
                LOG.exception("Error on watch, continuing")


if __name__ == "__main__":
    Main()
